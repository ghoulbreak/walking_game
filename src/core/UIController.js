// src/core/UIController.js
// Handles all UI elements and updates for the game

/**
 * Manages UI elements and their updates
 */
export class UIController {
    /**
     * Create a new UIController
     */
    constructor() {
      // Ensure DOM is ready before creating UI elements
      if (document.readyState === 'loading') {
        // Document still loading, wait for it to be ready
        document.addEventListener('DOMContentLoaded', () => {
          this._initializeUI();
        });
      } else {
        // Document already loaded, proceed immediately
        this._initializeUI();
      }
    }

    // New helper method to initialize UI
    _initializeUI() {
      // Create and cache UI elements
      this.createUIElements();
      
      // Get references to existing elements
      this.getUIReferences();
      
      console.log("UI Initialized. Loading screen element exists:", !!this.loadingScreen);
      
      // Verify loading screen elements were found
      if (!this.loadingScreen || !this.loadingBar || !this.loadingText) {
        console.error("Loading screen elements not found, trying again");
        // Wait a bit and try again - DOM might not be fully ready
        setTimeout(() => {
          this.getUIReferences();
          console.log("Retry: Loading screen element exists:", !!this.loadingScreen);
        }, 100);
      }
    }
  
    
    /**
     * Create necessary UI elements
     */
    createUIElements() {
      // Create main info panel
      const infoPanel = document.createElement('div');
      infoPanel.className = 'info';
      infoPanel.innerHTML = `
        <div id="fps">FPS: 0</div>
        <div id="position">Position: (0, 0, 0)</div>
        <div id="elevation">Elevation: 0m | Profile: appalachian</div>
        <div class="controls">WASD to move, SHIFT to sprint, SPACE to jump, Mouse to look</div>
        <div class="controls">Press 1-5 to switch terrain profiles, T to teleport</div>
        <div class="stamina-container">
          <div id="stamina-bar" class="stamina-bar"></div>
        </div>
      `;
      document.body.appendChild(infoPanel);
      
      // Create waypoint info panel
      const waypointPanel = document.createElement('div');
      waypointPanel.className = 'waypoint-info';
      waypointPanel.innerHTML = `
        <div id="waypoint-distance">Next waypoint: -- m</div>
        <div class="waypoint-progress">
          <div id="waypoint-progress-bar" class="waypoint-progress-bar"></div>
        </div>
      `;
      document.body.appendChild(waypointPanel);
      
      // Create loading screen
      const loadingScreen = document.createElement('div');
      loadingScreen.id = 'loading-screen';
      loadingScreen.className = 'loading-screen';
      loadingScreen.innerHTML = `
        <h1>Hierarchical Terrain Walking Simulator</h1>
        <div class="terrain-info">
          This simulator demonstrates a two-level hierarchical terrain system:
          <br><br>
          Level A: A large-scale (4096×4096) terrain providing overall landscape features
          <br><br>
          Level B: Detailed (256×256) chunks generated by upscaling and adding detail to sections of Level A
        </div>
        <div class="loading-bar-container">
          <div id="loading-bar" class="loading-bar"></div>
        </div>
        <div id="loading-text" class="loading-text">Generating terrain...</div>
        <div class="loading-tips">
          Tip: Press F to toggle chunk debug visualization. Press T to teleport to a random flat area.
        </div>
      `;
      document.body.appendChild(loadingScreen);
      
      // Create chunk info display
      const chunkInfo = document.createElement('div');
      chunkInfo.id = 'chunk-info';
      chunkInfo.style.position = 'absolute';
      chunkInfo.style.bottom = '10px';
      chunkInfo.style.left = '10px';
      chunkInfo.style.background = 'rgba(0, 0, 0, 0.5)';
      chunkInfo.style.color = 'white';
      chunkInfo.style.padding = '10px';
      chunkInfo.style.fontFamily = 'monospace';
      chunkInfo.style.borderRadius = '5px';
      document.body.appendChild(chunkInfo);
      
      // Add default CSS
      this.addDefaultStyles();
    }
    
    /**
     * Get references to existing UI elements
     */
    getUIReferences() {
      // Info panel elements
      this.fpsDisplay = document.getElementById('fps');
      this.positionDisplay = document.getElementById('position');
      this.elevationDisplay = document.getElementById('elevation');
      this.staminaBar = document.getElementById('stamina-bar');
      
      // Chunk info display
      this.chunkInfoDisplay = document.getElementById('chunk-info');
      
      // Waypoint elements
      this.waypointDistanceDisplay = document.getElementById('waypoint-distance');
      this.waypointProgressBar = document.getElementById('waypoint-progress-bar');
      
      // Loading screen elements
      this.loadingScreen = document.getElementById('loading-screen');
      this.loadingBar = document.getElementById('loading-bar');
      this.loadingText = document.getElementById('loading-text');
    }
    
    /**
     * Add default styles to the document
     */
    addDefaultStyles() {
      const style = document.createElement('style');
      style.textContent = `
        body {
          margin: 0;
          overflow: hidden;
          font-family: Arial, sans-serif;
        }
        canvas {
          width: 100%;
          height: 100%;
          display: block;
        }
        .info {
          position: absolute;
          top: 10px;
          left: 10px;
          background: rgba(0, 0, 0, 0.5);
          color: white;
          padding: 10px;
          font-family: monospace;
          pointer-events: none;
          border-radius: 5px;
        }
        .controls {
          margin-top: 10px;
          font-size: 14px;
        }
        .stamina-container {
          width: 200px;
          height: 15px;
          background-color: rgba(0, 0, 0, 0.5);
          margin-top: 8px;
          border-radius: 3px;
          overflow: hidden;
        }
        .stamina-bar {
          height: 100%;
          background-color: #4CAF50;
          width: 100%;
          transition: width 0.2s;
        }
        .stamina-low {
          background-color: #f44336;
        }
        .waypoint-info {
          position: absolute;
          bottom: 10px;
          right: 10px;
          background: rgba(0, 0, 0, 0.5);
          color: white;
          padding: 10px;
          font-family: monospace;
          border-radius: 5px;
        }
        .waypoint-progress {
          width: 200px;
          height: 10px;
          background-color: rgba(255, 255, 255, 0.2);
          margin-top: 5px;
          border-radius: 5px;
          overflow: hidden;
        }
        .waypoint-progress-bar {
          height: 100%;
          background-color: #ffaa00;
          width: 0%;
        }
        .loading-screen {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: #333;
          display: flex;
          flex-direction: column;
          justify-content: center;
          align-items: center;
          color: white;
          z-index: 1000;
        }
        .loading-bar-container {
          width: 300px;
          height: 20px;
          background-color: #222;
          border-radius: 10px;
          margin-top: 20px;
        }
        .loading-bar {
          height: 100%;
          width: 0%;
          background-color: #4CAF50;
          border-radius: 10px;
          transition: width 0.3s;
        }
        .loading-text {
          margin-top: 10px;
          font-family: monospace;
        }
        .loading-tips {
          max-width: 400px;
          text-align: center;
          color: #aaa;
          margin-top: 30px;
          font-style: italic;
        }
        .terrain-info {
          max-width: 400px;
          text-align: center;
          color: #fff;
          margin-top: 20px;
          font-size: 14px;
        }
        .notification {
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: rgba(0, 0, 0, 0.7);
          color: white;
          padding: 10px;
          border-radius: 5px;
          z-index: 1000;
          font-family: Arial, sans-serif;
        }
        .overlay {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.7);
          color: white;
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 2000;
          font-family: Arial, sans-serif;
        }
      `;
      document.head.appendChild(style);
    }
    
    /**
     * Show the loading screen
     */
    showLoadingScreen() {
      if (this.loadingScreen) {
        this.loadingScreen.style.display = 'flex';
        this.loadingScreen.style.opacity = '1';
      }
    }
    
    // Modified hideLoadingScreen method for more direct DOM manipulation
    hideLoadingScreen() {
      console.log("Attempting to hide loading screen");
      
      // Try getting a direct reference if our cached reference is missing
      const loadingScreen = this.loadingScreen || document.getElementById('loading-screen');
      
      if (loadingScreen) {
        console.log("Loading screen found, hiding it now");
        
        // Force style update with !important
        loadingScreen.style.cssText = `
          opacity: 0 !important; 
          transition: opacity 0.5s !important;
        `;
        
        setTimeout(() => {
          loadingScreen.style.cssText = `
            opacity: 0 !important;
            display: none !important;
          `;
          console.log("Loading screen hidden (display: none applied)");
        }, 500);
      } else {
        console.error("Loading screen element not found even with direct query");
      }
    }
    
    /**
     * Update loading progress
     * @param {number} progress - Progress percentage (0-100)
     * @param {string} message - Loading message to display
     */
    updateLoadingProgress(progress, message) {
      console.log(`Loading progress: ${progress}%, message: ${message}`);
      
      // Use direct element references as fallback
      const loadingBar = this.loadingBar || document.getElementById('loading-bar');
      const loadingText = this.loadingText || document.getElementById('loading-text');
      
      if (loadingBar) {
        // Force style update with !important
        loadingBar.style.cssText = `width: ${progress}% !important; transition: width 0.3s;`;
        console.log(`Set loading bar width to ${progress}%`);
      } else {
        console.error("loadingBar element not found even with direct query");
      }
      
      if (message && loadingText) {
        loadingText.textContent = message;
        console.log(`Updated loading text to: ${message}`);
      } else if (message) {
        console.error("loadingText element not found even with direct query");
      }
    }
    
    
    /**
     * Show a temporary notification
     * @param {string} message - Message to display
     * @param {number} duration - Duration in milliseconds
     */
    showNotification(message, duration = 2000) {
      const notification = document.createElement('div');
      notification.className = 'notification';
      notification.textContent = message;
      document.body.appendChild(notification);
      
      setTimeout(() => {
        document.body.removeChild(notification);
      }, duration);
    }
    
    /**
     * Show a fullscreen overlay with a message
     * @param {string} message - Message to display
     */
    showOverlay(message) {
      const overlay = document.createElement('div');
      overlay.className = 'overlay';
      overlay.innerHTML = `<div>${message}</div>`;
      
      // Store reference to remove later
      this.currentOverlay = overlay;
      document.body.appendChild(overlay);
    }
    
    /**
     * Hide the current overlay
     */
    hideOverlay() {
      if (this.currentOverlay && this.currentOverlay.parentNode) {
        document.body.removeChild(this.currentOverlay);
        this.currentOverlay = null;
      }
    }
    
    /**
     * Update UI elements with the latest game state
     * @param {Object} state - Current game state
     */
    update(state) {
      const { fps, player, terrain, waypointSystem } = state;
      
      // Update FPS display
      if (this.fpsDisplay) {
        this.fpsDisplay.textContent = `FPS: ${fps.toFixed(1)}`;
      }
      
      // Update position display
      if (this.positionDisplay && player) {
        const pos = player.position;
        this.positionDisplay.textContent = `Position: (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`;
      }
      
      // Update elevation display
      if (this.elevationDisplay && player && terrain) {
        const groundHeight = terrain.getHeightAt(player.position.x, player.position.z);
        this.elevationDisplay.textContent = `Elevation: ${groundHeight !== null ? groundHeight.toFixed(1) : '?'}m | Profile: ${terrain.activeProfile}`;
      }
      
      // Update stamina bar
      if (this.staminaBar && player) {
        const staminaPercent = (player.stamina.current / player.stamina.max) * 100;
        this.staminaBar.style.width = `${staminaPercent}%`;
        this.staminaBar.classList.toggle('stamina-low', staminaPercent < 30);
      }
      
      // Update chunk info display
      if (this.chunkInfoDisplay && terrain) {
        const loadedChunks = terrain.getLoadedChunks().length;
        const currentChunk = terrain.currentChunk;
        
        this.chunkInfoDisplay.innerHTML = `
          Micro chunks loaded: ${loadedChunks}<br>
          Current chunk: (${currentChunk.x}, ${currentChunk.z})<br>
          View distance: ${terrain.viewDistance} chunks<br>
          Chunk size: ${terrain.microSize} units
        `;
      }
      
      // Update waypoint tracking
      if (waypointSystem && this.waypointDistanceDisplay && this.waypointProgressBar) {
        const currentWaypoint = waypointSystem.getCurrentWaypoint();
        
        if (currentWaypoint && player) {
          // Calculate distance to waypoint
          const waypointPos = { x: currentWaypoint.x, z: currentWaypoint.z };
          const playerPos = { x: player.position.x, z: player.position.z };
          const distance = calculateDistance(playerPos, waypointPos);
          
          // Update distance display
          this.waypointDistanceDisplay.textContent = `Next waypoint: ${distance.toFixed(1)}m`;
          
          // Update progress bar
          const progress = waypointSystem.getProgress() * 100;
          this.waypointProgressBar.style.width = `${progress}%`;
        } else {
          this.waypointDistanceDisplay.textContent = 'No active waypoints';
          this.waypointProgressBar.style.width = '0%';
        }
      }
    }
  }
  
  /**
   * Calculate distance between two 2D points
   * @param {Object} point1 - First point with x, z coordinates
   * @param {Object} point2 - Second point with x, z coordinates
   * @returns {number} - Distance between the points
   */
  function calculateDistance(point1, point2) {
    const dx = point2.x - point1.x;
    const dz = point2.z - point1.z;
    return Math.sqrt(dx * dx + dz * dz);
  }